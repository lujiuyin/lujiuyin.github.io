<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。">
<meta property="og:type" content="website">
<meta property="og:title" content="汉秋城">
<meta property="og:url" content="http://hanqiu.info/index.html">
<meta property="og:site_name" content="汉秋城">
<meta property="og:description" content="天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="汉秋城">
<meta name="twitter:description" content="天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hanqiu.info/"/>





  <title>汉秋城</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">汉秋城</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanqiu.info/2017/10/19/🐂👃的第三方库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="汉秋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oanq2qjpp.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汉秋城">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/🐂👃的第三方库/" itemprop="url">🐂👃的第三方库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-19T10:24:31+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iCarousel                  卡片切换<br>JSPatch                     js控制oc代码，修复线上bug<br>FoldingTabBar        q版tabbar<br>MMProgressHUD   各种动画的提示框<br>IQKeyboardManager     键盘问题</p>
<p>Installing AFNetworking (3.1.0)<br>Installing AMTagListView (1.5.0)<br>Installing BaiduMapKit (3.2.1)<br>Installing FDFullscreenPopGesture (1.1)<br>Installing FMDB (2.6.2)<br>Installing FDFullscreenPopGesture (5.2.0)<br>Installing LFLiveKit (1.9.6)<br>Installing LTNavigationBar (2.1.9)<br>Installing MJExtension (3.0.13)<br>Installing MJRefresh (3.1.12)<br>Installing Masonry (1.0.2)<br>Installing ReactiveCocoa (4.1.0)<br>Installing Realm (2.4.3)<br>Installing Result (2.1.3)<br>Installing SDAutoLayout (2.1.7)<br>Installing SDWebImage (4.0.0)<br>Installing SVProgressHUD (2.1.2)<br>Installing UITableView+FDTemplateLayoutCell (1.4)<br>Installing UMengSocialCOM (5.2.1)<br>Installing WebViewJavascriptBridge (6.0.2)<br>Installing YYKit (1.0.9)<br>Installing pop (1.0.9)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanqiu.info/2017/10/19/UITableViewCell两种复用方式的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="汉秋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oanq2qjpp.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汉秋城">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/UITableViewCell两种复用方式的区别/" itemprop="url">UITableViewCell两种复用方式的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-19T10:23:16+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="两种方式："><a href="#两种方式：" class="headerlink" title="两种方式："></a>两种方式：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;  </div><div class="line">- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);</div></pre></td></tr></table></figure>
<p>那么这两种复用方式有什么区别呢？<br>从第二种方式的注释我们知道它是在iOS6上新增的，而且新增了一个参数indexpath。以前我们用第一种方式得到复用的cell一般是下面这样写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    static NSString *reuseIdentifier = @&quot;reuseIdentifier&quot;;</div><div class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:reuseIdentifier];</div><div class="line">    if (!cell) &#123;</div><div class="line">        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:reuseIdentifier];</div><div class="line">    &#125;</div><div class="line">    return cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为第一种方式的返回值是nullable的，所以它可能为空，我们需要考虑在复用cell为空是创建一个cell。而使用第二种方式则不必考虑为空的情况，但是它也是有前提的，在获取复用cell之前，它必须先注册一个cell，注册的方式有以下两种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)registerNib:(nullable UINib *)nib forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(5_0);</div><div class="line">- (void)registerClass:(nullable Class)cellClass forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);</div></pre></td></tr></table></figure>
<ul>
<li>当我们的cell是通过xib自定义的时候，调用<em>- (void)registerNib:(nullable UINib \</em>)nib forCellReuseIdentifier:(NSString *)identifier<em>注册，通过代码自定义的cell时，就调用</em>- (void)registerClass:(nullable Class)cellClass forCellReuseIdentifier:(NSString *)identifier*注册。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanqiu.info/2017/10/19/mac环境下配置本地svn服务器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="汉秋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oanq2qjpp.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汉秋城">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/mac环境下配置本地svn服务器/" itemprop="url">mac环境下配置本地svn服务器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-19T10:22:35+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们都知道在多人开发时，项目版本控制是非常必要的。好处就是每个人可以同时开发自己的模块，然后统一合入到svn仓库中去，只要我们处理好同时有两个人以上会接触到的文件的冲突问题，这样可以提高开发效率，还有就是使用svn我们把代码分散到服务器和每个人的电脑中，这样可以避免项目被误删恢复不了的问题。</p>
<p>今天心血来潮就在自己的mac上实践了一下，也是参考着网上的教程一步步配置的，记录在这里也算是对整个流程的一个总结吧。</p>
<p>首先，mac下是自带svn的服务器端和客户端的，我们不需要安装第三方软件就可以操作它，只不过没有那么直观。</p>
<hr>
<h3 id="创建代码仓库，用于存储客户端上传的代码"><a href="#创建代码仓库，用于存储客户端上传的代码" class="headerlink" title="创建代码仓库，用于存储客户端上传的代码"></a>创建代码仓库，用于存储客户端上传的代码</h3><p>根据网上的教程是在终端输入下面的命令创建代码仓库，此时该路径下会多出一些文件。但是在此之前必须确保/Users/ljy/Desktop/svn/mycode已经存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promote:~ ljy$ svnadmin create /Users/ljy/Desktop/svn/mycode</div><div class="line">promote:~ ljy$ cd /Users/ljy/Desktop/svn/mycode/</div><div class="line">promote:mycode ljy$ ls</div><div class="line">README.txt	db		hooks</div><div class="line">conf		format		locks</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1605186-bc5963fe9b4dc984.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目录结构.png"></p>
<hr>
<h3 id="配置svn用户权限"><a href="#配置svn用户权限" class="headerlink" title="配置svn用户权限"></a>配置svn用户权限</h3><p>配置svn用户权限涉及到conf文件夹下的三个文件authz、passws、svnserve.conf。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">promote:mycode ljy$ cd /Users/ljy/Desktop/svn/mycode/conf</div><div class="line">promote:conf ljy$ ls</div><div class="line">authz		passwd		svnserve.conf</div></pre></td></tr></table></figure></p>
<ol>
<li>首先打开svnserve.conf文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">promote:~ ljy$ cd /Users/ljy/Desktop/svn/mycode/conf</div><div class="line">promote:conf ljy$ ls</div><div class="line">authz		passwd		svnserve.conf</div><div class="line">promote:conf ljy$ vim svnserve.conf</div></pre></td></tr></table></figure>
</li>
</ol>
<p>将里面所有以一个#开头的行的#和空格删掉(  <strong> 空格一定要注意 </strong>)，###开头的注释不需要处理。</p>
<ol>
<li>添加用户<br>打开 passed文件，在[users]下面添加用户名和密码，格式为username = password</li>
<li>配置用户组和权限<ul>
<li>打开author文件，在[groups]下面添加组名和组内用户名，格式为mygroup = username1, username2</li>
<li>在[/]下面添加组的权限和用户的权限<br>组的权限格式@mygroup = rw<br>用户的权限格式username1 = rw</li>
</ul>
</li>
</ol>
<hr>
<h3 id="启动和关闭svn"><a href="#启动和关闭svn" class="headerlink" title="启动和关闭svn"></a>启动和关闭svn</h3><ul>
<li><p>启动svn<br>配置完上面的一系列流程之后，终端输入下面的命令启动svn，如果没有提示错误就说明svn启动成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promote:conf ljy$ svnserve -d -r /Users/ljy/Desktop/svn</div></pre></td></tr></table></figure>
</li>
<li><p>关闭svn<br>需要关闭svn时，我们打开mac的Finder，在应用程序的实用工具中找到活动监视器，搜索框输入svn就可以找到，然后选中退出进程即可。<br><img src="http://upload-images.jianshu.io/upload_images/1605186-5f8d6ef622673e14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关闭svn.png"></p>
</li>
</ul>
<hr>
<p>至此，我们的svn就配置完毕了。我们可以通过终端命令向svn仓库导入工程以及其他更多操作。可以在网上找到很多教程。</p>
<p>我是利用了第三方软件Versions来更直观的管理我的工程的。具体操作我去官网查询。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1605186-feccb359f06de5da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="versions.png"></p>
<hr>
<p>参考链接<a href="http://blog.csdn.net/lys07962000/article/details/17917467" target="_blank" rel="external">http://blog.csdn.net/lys07962000/article/details/17917467</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanqiu.info/2017/10/19/UITableViewCell高度自适应/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="汉秋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oanq2qjpp.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汉秋城">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/UITableViewCell高度自适应/" itemprop="url">UITableViewCell高度自适应</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-19T10:21:55+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有时我们在使用UITableView时，每个cell的高度不是定死的，它需要由每个cell里面的内容动态决定。<br>之前我们都是通过计算每个cell里面每个空间的高度之和，然后在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div></pre></td></tr></table></figure></p>
<p>中返回每个index path对应cell的高度。</p>
<p>通常计算UILabel的高度是使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (CGRect)boundingRectWithSize:(CGSize)size options:(NSStringDrawingOptions)options attributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attributes context:(nullable NSStringDrawingContext *)context NS_AVAILABLE(10_11, 7_0);</div></pre></td></tr></table></figure></p>
<p>但是在iOS8之后，我们可以使用更简单的方法实现。</p>
<ol>
<li>首先需要在xib或者SB中给cell中的元素添加top、bottom约束，然后通过设置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.tableview.estimatedRowHeight = 100.0;</div><div class="line">    self.tableview.rowHeight = UITableViewAutomaticDimension;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>来实现。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanqiu.info/2017/10/19/uiview-autoresizesSubviews/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="汉秋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oanq2qjpp.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汉秋城">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/uiview-autoresizesSubviews/" itemprop="url">uiview autoresizesSubviews</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-19T10:21:22+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="autoresizesSubviews"><a href="#autoresizesSubviews" class="headerlink" title="autoresizesSubviews"></a>autoresizesSubviews</h2><p>iOS有两大自动布局利器：autoresizing 和 autolayout（autolayout是IOS6以后新增）。autoresizing是UIView的属性，一直存在，使用也比较简单，但是没有autolayout那样强大。如果你的界面比较简单，要求的细节没有那么高，那么你完全可以使用autoresizing去进行自动布局。</p>
<p>typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) {<br>    UIViewAutoresizingNone                 = 0,<br>    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,<br>    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,<br>    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,<br>    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,<br>    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,<br>    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5<br>};</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanqiu.info/2017/10/19/iOS-setNeedsLayout等布局方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="汉秋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oanq2qjpp.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汉秋城">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/iOS-setNeedsLayout等布局方法/" itemprop="url">iOS-setNeedsLayout等布局方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-19T10:19:58+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="layoutSubviews"><a href="#layoutSubviews" class="headerlink" title="layoutSubviews"></a>layoutSubviews</h2><p>这个方法，默认没有做任何事情，需要子类进行重写 。 系统在很多时候会去调用这个方法：</p>
<p>1.初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发。<br>2.addSubview会触发layoutSubviews<br>3.设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化<br>4.滚动一个UIScrollView会触发layoutSubviews<br>5.旋转Screen会触发父UIView上的layoutSubviews事件<br>6.改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件</p>
<h2 id="setNeedsLayout"><a href="#setNeedsLayout" class="headerlink" title="setNeedsLayout"></a>setNeedsLayout</h2><p>标记为需要重新布局，不立即刷新，但layoutSubviews一定会被调用<br>配合layoutIfNeeded立即更新</p>
<h2 id="layoutIfNeeded"><a href="#layoutIfNeeded" class="headerlink" title="layoutIfNeeded"></a>layoutIfNeeded</h2><p>如果，有需要刷新的标记，立即调用layoutSubviews进行布局</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanqiu.info/2017/10/19/OpenGL-ES学习记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="汉秋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oanq2qjpp.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汉秋城">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/OpenGL-ES学习记录/" itemprop="url">OpenGL ES学习记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-19T10:14:31+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本学习记录参考OpenGL ES应用开发实践 指南iOS卷.pdf</p>
</blockquote>
<p>#3D渲染<br>屏幕只有2维，想要在屏幕展示3D的效果，首先我们就需要一些3D效果的数据，然后将这些3D数据通过计算机的计算、渲染转化为2D的数据，从而迷惑人们的眼睛使其产生3D的效果。</p>
<p>用3D数据生成一个2D图像的过程就是所谓的渲染。计算机中图片是有一个个像素构成的，当你把一张图片放大很多倍后你会发现它是由一个个小方格组成了一张图。每个小方格都有自己的颜色，如果一张图由很少的像素组成的话，就会很模糊、很方。</p>
<p>OpenGL ES部分运行在cpu上，部分运行在gpu上。OpenGL ES横跨两个处理器之间。<br>CPU负责提供3D数据，将计算好的数据提供给GPU渲染，但是由于计算机对于内存的访问较慢，且数据交换时会阻塞cpu运行。</p>
<p>#缓存<br>对于上面遇到的问题，OpenGL ES为两者的数据交换定义了缓存的概念。首先cpu将计算的数据放入换乘，然后就可以放弃对缓存的控制去处理其他事务，这是gpu就可以独自占有缓存的控制权。</p>
<p>#####为缓存提供数据有七个步骤，并附上对应的C语言函数：</p>
<ol>
<li><p>生成（Generate）——请求OpenGL ES为缓存生成一个独一无二的缓存标识符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">glGenBuffers()</div></pre></td></tr></table></figure>
</li>
<li><p>绑定（Bind）——告诉OpenGL ES为接下来的运算使用一个缓存。                       </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">glBindBuffer()</div></pre></td></tr></table></figure>
</li>
<li><p>缓存数据（Buffer Data）——让OpenGL ES为当前绑定的缓存分配并初始化足够的连续内存（通常是从cpu控制的内存复制数据到分配的内存）ps.此处有点不明所以                              </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">glBufferData()</div></pre></td></tr></table></figure>
</li>
<li><p>启用（Enable）或者禁用（Disable）——告诉OpenGL ES在接下来的渲染中是否使用缓存中的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">glEnableVertexAttribArray()</div></pre></td></tr></table></figure>
</li>
<li><p>设置指针（Set Pointers）——告诉OpenGL ES在缓存中的数据类型及所有要访问的数据的内存偏移值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">glVertexAttribPointer()</div><div class="line">```                                                         </div><div class="line">6. 绘图（Draw）——告诉OpenGL ES使用当前绑定并启用的缓存数据去渲染整个场景或某个场景中的一部分。</div></pre></td></tr></table></figure>
</li>
</ol>
<p>glDrawArrays()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">7. 删除（Delete）——告诉OpenGL ES删除以前生成的缓存  并释放相关资源。</div></pre></td></tr></table></figure></p>
<p>glDeleteBuffers()<br>```</p>
<p>#帧缓存<br>上面渲染出来的数据该放在什么地方？这里就讲到了帧缓存。接受渲染结果的缓冲区叫做帧缓存。程序会像任何其他种类的缓存一样生成、绑定、删除帧缓存。为啥它没有七个步骤呢？原来帧缓存不需要初始化，因为渲染指令会在适当的时候替换缓存中的内容。帧缓存会在被绑定的时候隐式开启，同时OpenGL ES会自动地根据特定平台的硬件配置来设置数据的类型和偏移。</p>
<p>#OpenGL ES的上下文<br>OpenGL ES是一个状态机，在程序中设置的配置值会被封装到OpenGL ES上下文(context)中。</p>
<p>#点、线、三角形<br>OpenGL ES使用顶点数据来定义点、线、三角形。OpenGL ES只渲染顶点、线段和三角形。</p>
<p>#Core Animation</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hanqiu.info/2017/10/18/OC二叉树相关操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="汉秋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oanq2qjpp.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汉秋城">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/OC二叉树相关操作/" itemprop="url">OC二叉树相关操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T17:06:10+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#二叉树-你必须要懂！（二叉树相关算法实现-iOS）</p>
<p>####<a href="http://www.cnblogs.com/manji/p/4903990.html" target="_blank" rel="external">http://www.cnblogs.com/manji/p/4903990.html原文链接</a><br>这几天详细了解了下二叉树的相关算法，原因是看了唐boy的一篇博客（<a href="http://blog.devtang.com/blog/2015/06/16/talk-about-tech-interview/" target="_blank" rel="external">你会翻转二叉树吗？</a>），还有一篇关于<a href="http://www.cocoachina.com/programmer/20151015/13687.html" target="_blank" rel="external">百度的校园招聘面试经历</a>，深刻体会到二叉树的重要性。于是乎，从网上收集并整理了一些关于二叉树的资料，及相关算法的实现（主要是Objective-C的，但是算法思想是相通的），以便以后复习时查阅。</p>
<p>##什么是二叉树？<br>在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”和“右子树”，左子树和右子树同时也是二叉树。二叉树的子树有左右之分，并且次序不能任意颠倒。二叉树是递归定义的，所以一般二叉树的相关题目也都可以使用递归的思想来解决，当然也有一些可以使用非递归的思想解决，我下面列出的一些算法有些采用了递归，有些是非递归的。</p>
<p>#什么是二叉排序树？<br>二叉排序树又叫二叉查找树或者二叉搜索树，它首先是一个二叉树，而且必须满足下面的条件：<br>1）若左子树不空，则左子树上所有结点的值均小于它的根节点的值；<br>2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值<br>3）左、右子树也分别为二叉排序树<br>4）没有键值相等的节点（？可能是因为不好处理键值相等的节点到底是左节点还是右节点吧）<br>概念就介绍这么多，都是来自网上，下面主要看算法和具体实现代码。</p>
<p>#二叉树节点定义<br>采用单项链表的形式，只从根节点指向孩子节点，不保存父节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树节点</div><div class="line"> */</div><div class="line">@interface BinaryTreeNode : NSObject</div><div class="line"></div><div class="line">/**</div><div class="line"> *  值</div><div class="line"> */</div><div class="line">@property (nonatomic, assign) NSInteger value;</div><div class="line">/**</div><div class="line"> *  左节点</div><div class="line"> */</div><div class="line">@property (nonatomic, strong) BinaryTreeNode *leftNode;</div><div class="line">/**</div><div class="line"> *  右节点</div><div class="line"> */</div><div class="line">@property (nonatomic, strong) BinaryTreeNode *rightNode;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>#创建二叉排序树<br>二叉树中左右节点值本身没有大小之分，所以如果要创建二叉树，就需要考虑如何处理某个节点是左节点还是右节点，如何终止某个子树而切换到另一个子树。 因此我选择了二叉排序树，二叉排序树中对于左右节点有明确的要求，程序可以自动根据键值大小自动选择是左节点还是右节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  创建二叉排序树</div><div class="line"> *  二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值</div><div class="line"> *</div><div class="line"> *  @param values 数组</div><div class="line"> *</div><div class="line"> *  @return 二叉树根节点</div><div class="line"> */</div><div class="line">+ (BinaryTreeNode *)createTreeWithValues:(NSArray *)values &#123;</div><div class="line">    </div><div class="line">    BinaryTreeNode *root = nil;</div><div class="line">    for (NSInteger i=0; i&lt;values.count; i++) &#123;</div><div class="line">        NSInteger value = [(NSNumber *)[values objectAtIndex:i] integerValue];</div><div class="line">        root = [BinaryTree addTreeNode:root value:value];</div><div class="line">    &#125;</div><div class="line">    return root;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  向二叉排序树节点添加一个节点</div><div class="line"> *</div><div class="line"> *  @param treeNode 根节点</div><div class="line"> *  @param value    值</div><div class="line"> *</div><div class="line"> *  @return 根节点</div><div class="line"> */</div><div class="line">+ (BinaryTreeNode *)addTreeNode:(BinaryTreeNode *)treeNode value:(NSInteger)value &#123;</div><div class="line">    //根节点不存在，创建节点</div><div class="line">    if (!treeNode) &#123;</div><div class="line">        treeNode = [BinaryTreeNode new];</div><div class="line">        treeNode.value = value;</div><div class="line">        NSLog(@&quot;node:%@&quot;, @(value));</div><div class="line">    &#125;</div><div class="line">    else if (value &lt;= treeNode.value) &#123;</div><div class="line">        NSLog(@&quot;to left&quot;);</div><div class="line">        //值小于根节点，则插入到左子树</div><div class="line">        treeNode.leftNode = [BinaryTree addTreeNode:treeNode.leftNode value:value];</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        NSLog(@&quot;to right&quot;);</div><div class="line">        //值大于根节点，则插入到右子树</div><div class="line">        treeNode.rightNode = [BinaryTree addTreeNode:treeNode.rightNode value:value];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return treeNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树中某个位置的节点<br>类似索引操作，按层次遍历，位置从0开始算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树中某个位置的节点（按层次遍历）</div><div class="line"> *</div><div class="line"> *  @param index    按层次遍历树时的位置(从0开始算)</div><div class="line"> *  @param rootNode 树根节点</div><div class="line"> *</div><div class="line"> *  @return 节点</div><div class="line"> */</div><div class="line">+ (BinaryTreeNode *)treeNodeAtIndex:(NSInteger)index inTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    //按层次遍历</div><div class="line">    if (!rootNode || index &lt; 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列</div><div class="line">    [queueArray addObject:rootNode]; //压入根节点</div><div class="line">    while (queueArray.count &gt; 0) &#123;</div><div class="line">        </div><div class="line">        BinaryTreeNode *node = [queueArray firstObject];</div><div class="line">        if (index == 0) &#123;</div><div class="line">            return node;</div><div class="line">        &#125;</div><div class="line">        [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则</div><div class="line">        index--; //移除节点，index减少</div><div class="line">        </div><div class="line">        if (node.leftNode) &#123;</div><div class="line">            [queueArray addObject:node.leftNode]; //压入左节点</div><div class="line">        &#125;</div><div class="line">        if (node.rightNode) &#123;</div><div class="line">            [queueArray addObject:node.rightNode]; //压入右节点</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //层次遍历完，仍然没有找到位置，返回nil</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#先序遍历<br>先访问根，再遍历左子树，再遍历右子树。典型的递归思想。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  先序遍历</div><div class="line"> *  先访问根，再遍历左子树，再遍历右子树</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *  @param handler  访问节点处理函数</div><div class="line"> */</div><div class="line">+ (void)preOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123;</div><div class="line">    if (rootNode) &#123;</div><div class="line">        </div><div class="line">        if (handler) &#123;</div><div class="line">            handler(rootNode);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        [self preOrderTraverseTree:rootNode.leftNode handler:handler];</div><div class="line">        [self preOrderTraverseTree:rootNode.rightNode handler:handler];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用方法如下：（用到了block）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *orderArray = [NSMutableArray array];</div><div class="line">[BinaryTree preOrderTraverseTree:root handler:^(BinaryTreeNode *treeNode) &#123;</div><div class="line">     [orderArray addObject:@(treeNode.value)];</div><div class="line">&#125;];</div><div class="line">NSLog(@&quot;先序遍历结果：%@&quot;, [orderArray componentsJoinedByString:@&quot;,&quot;]);</div></pre></td></tr></table></figure></p>
<p>#中序遍历<br>先遍历左子树，再访问根，再遍历右子树。<br>对于二叉排序树来说，中序遍历得到的序列是一个从小到大排序好的序列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  中序遍历</div><div class="line"> *  先遍历左子树，再访问根，再遍历右子树</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *  @param handler  访问节点处理函数</div><div class="line"> */</div><div class="line">+ (void)inOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123;</div><div class="line">    if (rootNode) &#123;</div><div class="line">        [self inOrderTraverseTree:rootNode.leftNode handler:handler];</div><div class="line">        </div><div class="line">        if (handler) &#123;</div><div class="line">            handler(rootNode);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        [self inOrderTraverseTree:rootNode.rightNode handler:handler];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#后序遍历<br>先遍历左子树，再遍历右子树，再访问根<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  后序遍历</div><div class="line"> *  先遍历左子树，再遍历右子树，再访问根</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *  @param handler  访问节点处理函数</div><div class="line"> */</div><div class="line">+ (void)postOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123;</div><div class="line">    if (rootNode) &#123;</div><div class="line">        [self postOrderTraverseTree:rootNode.leftNode handler:handler];</div><div class="line">        [self postOrderTraverseTree:rootNode.rightNode handler:handler];</div><div class="line">        </div><div class="line">        if (handler) &#123;</div><div class="line">            handler(rootNode);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#层次遍历<br>按照从上到下、从左到右的次序进行遍历。先遍历完一层，再遍历下一层，因此又叫广度优先遍历。需要用到队列，在OC里可以用可变数组来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  层次遍历（广度优先）</div><div class="line"> *</div><div class="line"> *  @param rootNode 二叉树根节点</div><div class="line"> *  @param handler  访问节点处理函数</div><div class="line"> */</div><div class="line">+ (void)levelTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列</div><div class="line">    [queueArray addObject:rootNode]; //压入根节点</div><div class="line">    while (queueArray.count &gt; 0) &#123;</div><div class="line">        </div><div class="line">        BinaryTreeNode *node = [queueArray firstObject];</div><div class="line">        </div><div class="line">        if (handler) &#123;</div><div class="line">            handler(node);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则</div><div class="line">        if (node.leftNode) &#123;</div><div class="line">            [queueArray addObject:node.leftNode]; //压入左节点</div><div class="line">        &#125;</div><div class="line">        if (node.rightNode) &#123;</div><div class="line">            [queueArray addObject:node.rightNode]; //压入右节点</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树的深度<br>二叉树的深度定义为：从根节点到叶子结点依次经过的结点形成树的一条路径,最长路径的长度为树的深度。</p>
<p>1）如果根节点为空，则深度为0；</p>
<p>2）如果左右节点都是空，则深度为1；</p>
<p>3）递归思想：二叉树的深度=max（左子树的深度，右子树的深度）+ 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树的深度</div><div class="line"> *</div><div class="line"> *  @param rootNode 二叉树根节点</div><div class="line"> *</div><div class="line"> *  @return 二叉树的深度</div><div class="line"> */</div><div class="line">+ (NSInteger)depthOfTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //左子树深度</div><div class="line">    NSInteger leftDepth = [self depthOfTree:rootNode.leftNode];</div><div class="line">    //右子树深度</div><div class="line">    NSInteger rightDepth = [self depthOfTree:rootNode.rightNode];</div><div class="line">    </div><div class="line">    return MAX(leftDepth, rightDepth) + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树的宽度<br>二叉树的宽度定义为各层节点数的最大值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树的宽度</div><div class="line"> *</div><div class="line"> *  @param rootNode 二叉树根节点</div><div class="line"> *</div><div class="line"> *  @return 二叉树宽度</div><div class="line"> */</div><div class="line">+ (NSInteger)widthOfTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列</div><div class="line">    [queueArray addObject:rootNode]; //压入根节点</div><div class="line">    NSInteger maxWidth = 1; //最大的宽度，初始化为1（因为已经有根节点）</div><div class="line">    NSInteger curWidth = 0; //当前层的宽度</div><div class="line">    </div><div class="line">    while (queueArray.count &gt; 0) &#123;</div><div class="line">        </div><div class="line">        curWidth = queueArray.count;</div><div class="line">        //依次弹出当前层的节点</div><div class="line">        for (NSInteger i=0; i&lt;curWidth; i++) &#123;</div><div class="line">            BinaryTreeNode *node = [queueArray firstObject];</div><div class="line">            [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则</div><div class="line">            //压入子节点</div><div class="line">            if (node.leftNode) &#123;</div><div class="line">                [queueArray addObject:node.leftNode];</div><div class="line">            &#125;</div><div class="line">            if (node.rightNode) &#123;</div><div class="line">                [queueArray addObject:node.rightNode];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //宽度 = 当前层节点数</div><div class="line">        maxWidth = MAX(maxWidth, queueArray.count);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return maxWidth;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树的所有节点数<br>递归思想：二叉树所有节点数=左子树节点数+右子树节点数+1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树的所有节点数</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return 所有节点数</div><div class="line"> */</div><div class="line">+ (NSInteger)numberOfNodesInTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    //节点数=左子树节点数+右子树节点数+1（根节点）</div><div class="line">    return [self numberOfNodesInTree:rootNode.leftNode] + [self numberOfNodesInTree:rootNode.rightNode] + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树某层中的节点数<br>1）根节点为空，则节点数为0；</p>
<p>2）层为1，则节点数为1（即根节点）</p>
<p>3）递归思想：二叉树第k层节点数=左子树第k-1层节点数+右子树第k-1层节点数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树某层中的节点数</div><div class="line"> *</div><div class="line"> *  @param level    层</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return 层中的节点数</div><div class="line"> */</div><div class="line">+ (NSInteger)numberOfNodesOnLevel:(NSInteger)level inTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode || level &lt; 1) &#123; //根节点不存在或者level&lt;0</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if (level == 1) &#123; //level=1，返回1（根节点）</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    //递归：level层节点数 = 左子树level-1层节点数+右子树level-1层节点数</div><div class="line">    return [self numberOfNodesOnLevel:level-1 inTree:rootNode.leftNode] + [self numberOfNodesOnLevel:level-1 inTree:rootNode.rightNode];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树叶子节点数<br>叶子节点，又叫终端节点，是左右子树都是空的节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树叶子节点数</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return 叶子节点数</div><div class="line"> */</div><div class="line">+ (NSInteger)numberOfLeafsInTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    //左子树和右子树都是空，说明是叶子节点</div><div class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    //递归：叶子数 = 左子树叶子数 + 右子树叶子数</div><div class="line">    return [self numberOfLeafsInTree:rootNode.leftNode] + [self numberOfLeafsInTree:rootNode.rightNode];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树最大距离（二叉树的直径）<br>二叉树中任意两个节点都有且仅有一条路径，这个路径的长度叫这两个节点的距离。二叉树中所有节点之间的距离的最大值就是二叉树的直径。</p>
<p>有一种解法，把这个最大距离划分了3种情况：</p>
<p>1）这2个节点分别在根节点的左子树和右子树上，他们之间的路径肯定经过根节点，而且他们肯定是根节点左右子树上最远的叶子节点（他们到根节点的距离=左右子树的深度）。</p>
<p>2）这2个节点都在左子树上</p>
<p>3）这2个节点都在右子树上</p>
<p>综上，只要取这3种情况中的最大值，就是二叉树的直径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树最大距离（直径）</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return 最大距离</div><div class="line"> */</div><div class="line">+ (NSInteger)maxDistanceOfTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">//    方案一：（递归次数较多，效率较低）</div><div class="line">    //分3种情况：</div><div class="line">    //1、最远距离经过根节点：距离 = 左子树深度 + 右子树深度</div><div class="line">    NSInteger distance = [self depthOfTree:rootNode.leftNode] + [self depthOfTree:rootNode.rightNode];</div><div class="line">    //2、最远距离在根节点左子树上，即计算左子树最远距离</div><div class="line">    NSInteger disLeft = [self maxDistanceOfTree:rootNode.leftNode];</div><div class="line">    //3、最远距离在根节点右子树上，即计算右子树最远距离</div><div class="line">    NSInteger disRight = [self maxDistanceOfTree:rootNode.rightNode];</div><div class="line">    </div><div class="line">    return MAX(MAX(disLeft, disRight), distance);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方案效率较低，因为计算子树的深度和最远距离是分开递归的，存在重复递归遍历的情况。其实一次递归，就可以分别计算出深度和最远距离，于是有了第二种方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树最大距离（直径）</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return 最大距离</div><div class="line"> */</div><div class="line">+ (NSInteger)maxDistanceOfTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">//    方案2：将计算节点深度和最大距离放到一次递归中计算，方案一是分别单独递归计算深度和最远距离</div><div class="line">    TreeNodeProperty *p = [self propertyOfTreeNode:rootNode];</div><div class="line">    return p.distance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  计算树节点的最大深度和最大距离</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return TreeNodeProperty</div><div class="line"> */</div><div class="line">+ (TreeNodeProperty *)propertyOfTreeNode:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    </div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    TreeNodeProperty *left = [self propertyOfTreeNode:rootNode.leftNode];</div><div class="line">    TreeNodeProperty *right = [self propertyOfTreeNode:rootNode.rightNode];</div><div class="line">    TreeNodeProperty *p = [TreeNodeProperty new];</div><div class="line">    //节点的深度depth = 左子树深度、右子树深度中最大值+1（+1是因为根节点占了1个depth）</div><div class="line">    p.depth = MAX(left.depth, right.depth) + 1;</div><div class="line">    //最远距离 = 左子树最远距离、右子树最远距离和横跨左右子树最远距离中最大值</div><div class="line">    p.distance = MAX(MAX(left.distance, right.distance), left.depth+right.depth);</div><div class="line">    </div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树中某个节点到根节点的路径<br>既是寻路问题，又是查找节点问题。</p>
<p>定义一个存放路径的栈（不是队列了，但是还是用可变数组来实现的）</p>
<p>1）压入根节点，再从左子树中查找（递归进行的），如果未找到，再从右子树中查找，如果也未找到，则弹出根节点，再遍历栈中上一个节点。</p>
<p>2）如果找到，则栈中存放的节点就是路径所经过的节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树中某个节点到根节点的路径</div><div class="line"> *</div><div class="line"> *  @param treeNode 节点</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return 存放路径节点的数组</div><div class="line"> */</div><div class="line">+ (NSArray *)pathOfTreeNode:(BinaryTreeNode *)treeNode inTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    NSMutableArray *pathArray = [NSMutableArray array];</div><div class="line">    [self isFoundTreeNode:treeNode inTree:rootNode routePath:pathArray];</div><div class="line">    return pathArray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  查找某个节点是否在树中</div><div class="line"> *</div><div class="line"> *  @param treeNode 待查找的节点</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *  @param path  根节点到待查找节点的路径</div><div class="line"> *</div><div class="line"> *  @return YES：找到，NO：未找到</div><div class="line"> */</div><div class="line">+ (BOOL)isFoundTreeNode:(BinaryTreeNode *)treeNode inTree:(BinaryTreeNode *)rootNode routePath:(NSMutableArray *)path &#123;</div><div class="line">    </div><div class="line">    if (!rootNode || !treeNode) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //找到节点</div><div class="line">    if (rootNode == treeNode) &#123;</div><div class="line">        [path addObject:rootNode];</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    //压入根节点，进行递归</div><div class="line">    [path addObject:rootNode];</div><div class="line">    //先从左子树中查找</div><div class="line">    BOOL find = [self isFoundTreeNode:treeNode inTree:rootNode.leftNode routePath:path];</div><div class="line">    //未找到，再从右子树查找</div><div class="line">    if (!find) &#123;</div><div class="line">        find = [self isFoundTreeNode:treeNode inTree:rootNode.rightNode routePath:path];</div><div class="line">    &#125;</div><div class="line">    //如果2边都没查找到，则弹出此根节点</div><div class="line">    if (!find) &#123;</div><div class="line">        [path removeLastObject];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return find;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树中两个节点最近的公共父节点<br>首先需要明白，根节点肯定是二叉树中任意两个节点的公共父节点（不一定是最近的），因此二叉树中2个节点的最近公共父节点一定在从根节点到这个节点的路径上。因此我们可以先分别找到从根节点到这2个节点的路径，再从这两个路径中找到最近的公共父节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树中两个节点最近的公共父节点</div><div class="line"> *</div><div class="line"> *  @param nodeA    第一个节点</div><div class="line"> *  @param nodeB    第二个节点</div><div class="line"> *  @param rootNode 二叉树根节点</div><div class="line"> *</div><div class="line"> *  @return 最近的公共父节点</div><div class="line"> */</div><div class="line">+ (BinaryTreeNode *)parentOfNode:(BinaryTreeNode *)nodeA andNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode || !nodeA || !nodeB) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    if (nodeA == nodeB) &#123;</div><div class="line">        return nodeA;</div><div class="line">    &#125;</div><div class="line">    //从根节点到节点A的路径</div><div class="line">    NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode];</div><div class="line">    //从根节点到节点B的路径</div><div class="line">    NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode];</div><div class="line">    //其中一个节点不在树中，则没有公共父节点</div><div class="line">    if (pathA.count == 0 || pathB == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    //从后往前推，查找第一个出现的公共节点</div><div class="line">    for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123;</div><div class="line">        for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123;</div><div class="line">            if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123;</div><div class="line">                //找到</div><div class="line">                return [pathA objectAtIndex:i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树中两个节点之间的路径<br>从查找最近公共父节点衍生出来的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树中两个节点之间的路径</div><div class="line"> *</div><div class="line"> *  @param nodeA    第一个节点</div><div class="line"> *  @param nodeB    第二个节点</div><div class="line"> *  @param rootNode 二叉树根节点</div><div class="line"> *</div><div class="line"> *  @return 两个节点间的路径</div><div class="line"> */</div><div class="line">+ (NSArray *)pathFromNode:(BinaryTreeNode *)nodeA toNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode || !nodeA || !nodeB) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    NSMutableArray *path = [NSMutableArray array];</div><div class="line">    if (nodeA == nodeB) &#123;</div><div class="line">        [path addObject:nodeA];</div><div class="line">        [path addObject:nodeB];</div><div class="line">        return path;</div><div class="line">    &#125;</div><div class="line">    //从根节点到节点A的路径</div><div class="line">    NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode];</div><div class="line">    //从根节点到节点B的路径</div><div class="line">    NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode];</div><div class="line">    //其中一个节点不在树中，则没有路径</div><div class="line">    if (pathA.count == 0 || pathB == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    //从后往前推，查找第一个出现的公共节点</div><div class="line">    for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123;</div><div class="line">        [path addObject:[pathA objectAtIndex:i]];</div><div class="line">        for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123;</div><div class="line">            //找到公共父节点，则将pathB中后面的节点压入path</div><div class="line">            if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123;</div><div class="line">                j++; //j++是为了避开公共父节点</div><div class="line">                while (j&lt;pathB.count) &#123;</div><div class="line">                    [path addObject:[pathB objectAtIndex:j]];</div><div class="line">                    j++;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                return path;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树两个节点之间的距离<br>可以从两个节点之间的路径衍生出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树两个节点之间的距离</div><div class="line"> *</div><div class="line"> *  @param nodeA    第一个节点</div><div class="line"> *  @param nodeB    第二个节点</div><div class="line"> *  @param rootNode 二叉树根节点</div><div class="line"> *</div><div class="line"> *  @return 两个节点间的距离（-1：表示没有找到路径）</div><div class="line"> */</div><div class="line">+ (NSInteger)distanceFromNode:(BinaryTreeNode *)nodeA toNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode || !nodeA || !nodeB) &#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    if (nodeA == nodeB) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    //从根节点到节点A的路径</div><div class="line">    NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode];</div><div class="line">    //从根节点到节点B的路径</div><div class="line">    NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode];</div><div class="line">    //其中一个节点不在树中，则没有路径</div><div class="line">    if (pathA.count == 0 || pathB == 0) &#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    //从后往前推，查找第一个出现的公共节点</div><div class="line">    for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123;</div><div class="line">        for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123;</div><div class="line">            //找到公共父节点</div><div class="line">            if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123;</div><div class="line">                //距离=路径节点数-1 （这里要-2，因为公共父节点重复了一次）</div><div class="line">                return (pathA.count - i) + (pathB.count - j) - 2;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#翻转二叉树<br>你会翻转二叉树吗？如果不会，那对不起，我们不会录用你！</p>
<p>翻转二叉树，又叫求二叉树的镜像，就是把二叉树的左右子树对调（当然是递归的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  翻转二叉树（又叫：二叉树的镜像）</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return 翻转后的树根节点（其实就是原二叉树的根节点）</div><div class="line"> */</div><div class="line">+ (BinaryTreeNode *)invertBinaryTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</div><div class="line">        return rootNode;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [self invertBinaryTree:rootNode.leftNode];</div><div class="line">    [self invertBinaryTree:rootNode.rightNode];</div><div class="line">    </div><div class="line">    BinaryTreeNode *tempNode = rootNode.leftNode;</div><div class="line">    rootNode.leftNode = rootNode.rightNode;</div><div class="line">    rootNode.rightNode = tempNode;</div><div class="line">    </div><div class="line">    return rootNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#判断二叉树是否完全二叉树<br>完全二叉树定义为：若设二叉树的高度为h，除第h层外，其它各层的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布。</p>
<p>完全二叉树必须满足2个条件：</p>
<p>1）如果某个节点的右子树不为空，则它的左子树必须不为空</p>
<p>2）如果某个节点的右子树为空，则排在它后面的节点必须没有孩子节点</p>
<p>这里还需要理解“排在它后面的节点”，回头看看层次遍历算法，我们就能知道在层次遍历时，是从上到下从左到右遍历的，先将根节点弹出队列，再压入孩子节点，因此“排在它后面的节点”有2种情况：</p>
<p>1）同层次的后面的节点</p>
<p>2）同层次的前面的节点的孩子节点（因为遍历前面的节点时，会弹出节点，同时将孩子节点压入队列）</p>
<p>通过上面的分析，我们可以设置一个标志位flag，当子树满足完全二叉树时，设置flag=YES。当flag=YES而节点又破坏了完全二叉树的条件，那么它就不是完全二叉树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  是否完全二叉树</div><div class="line"> *  完全二叉树：若设二叉树的高度为h，除第h层外，其它各层的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return YES：是完全二叉树，NO：不是完全二叉树</div><div class="line"> */</div><div class="line">+ (BOOL)isCompleteBinaryTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    //左子树和右子树都是空，则是完全二叉树</div><div class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    //左子树是空，右子树不是空，则不是完全二叉树</div><div class="line">    if (!rootNode.leftNode &amp;&amp; rootNode.rightNode) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //按层次遍历节点，找到满足完全二叉树的条件：</div><div class="line">    //条件1：如果某个节点的右子树不为空，则它的左子树必须不为空</div><div class="line">    //条件2：如果某个节点的右子树为空，则排在它后面的节点必须没有孩子节点</div><div class="line">    //排在该节点后面的节点有2种：1）同层次的后面的节点 2）同层次的前面的节点的孩子节点（因为遍历前面的节点的时候，会将节点从队列里pop，同时把它的孩子节点push到队列里）</div><div class="line">    NSMutableArray *queue = [NSMutableArray array];</div><div class="line">    [queue addObject:rootNode];</div><div class="line">    BOOL isComplete = NO; //是否已经满足完全二叉树</div><div class="line">    while (queue.count &gt; 0) &#123;</div><div class="line">        BinaryTreeNode *node = [queue firstObject];</div><div class="line">        [queue removeObjectAtIndex:0];</div><div class="line">        </div><div class="line">        //左子树为空且右子树不为空，则不是完全二叉树</div><div class="line">        if (!node.leftNode &amp;&amp; node.rightNode) &#123;</div><div class="line">            return NO;</div><div class="line">        &#125;</div><div class="line">        if (isComplete &amp;&amp; (node.leftNode || node.rightNode)) &#123;</div><div class="line">            //前面的节点已满足完全二叉树,如果还有孩子节点，则不是完全二叉树</div><div class="line">            return NO;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //右子树为空，则已经满足完全二叉树</div><div class="line">        if (!node.rightNode) &#123;</div><div class="line">            isComplete = YES;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //压入</div><div class="line">        if (node.leftNode) &#123;</div><div class="line">            [queue addObject:node.leftNode];</div><div class="line">        &#125;</div><div class="line">        if (node.rightNode) &#123;</div><div class="line">            [queue addObject:node.rightNode];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return isComplete;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#判断二叉树是否满二叉树<br> 满二叉树定义为：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树</p>
<p> 满二叉树的一个特性是：叶子数=2^(深度-1)，因此我们可以根据这个特性来判断二叉树是否是满二叉树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  是否满二叉树</div><div class="line"> *  满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return YES：满二叉树，NO：非满二叉树</div><div class="line"> */</div><div class="line">+ (BOOL)isFullBinaryTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //二叉树深度</div><div class="line">    NSInteger depth = [self depthOfTree:rootNode];</div><div class="line">    //二叉树叶子节点数</div><div class="line">    NSInteger leafNum = [self numberOfLeafsInTree:rootNode];</div><div class="line">    </div><div class="line">    //满二叉树特性：叶子数=2^(深度-1)</div><div class="line">    if (leafNum == pow(2, (depth - 1))) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#判断二叉树是否平衡二叉树<br>平衡二叉树定义为：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树又叫AVL树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  是否平衡二叉树</div><div class="line"> *  平衡二叉树：即AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return YES：平衡二叉树，NO：非平衡二叉树</div><div class="line"> */</div><div class="line">+ (BOOL)isAVLBinaryTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    static NSInteger height;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        height = 0;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</div><div class="line">        height = 1;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    BOOL isAVLLeft = [self isAVLBinaryTree:rootNode.leftNode];</div><div class="line">    NSInteger heightLeft = height;</div><div class="line">    BOOL isAVLRight = [self isAVLBinaryTree:rootNode.rightNode];</div><div class="line">    NSInteger heightRight = height;</div><div class="line">    </div><div class="line">    height = MAX(heightLeft, heightRight)+1;</div><div class="line">    </div><div class="line">    if (isAVLLeft &amp;&amp; isAVLRight &amp;&amp; ABS(heightLeft-heightRight) &lt;= 1) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://oanq2qjpp.bkt.clouddn.com/avatar.jpg"
                alt="汉秋" />
            
              <p class="site-author-name" itemprop="name">汉秋</p>
              <p class="site-description motion-element" itemprop="description">天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/lujiuyin" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">汉秋</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
