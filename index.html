<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。">
<meta property="og:type" content="website">
<meta property="og:title" content="汉秋城">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="汉秋城">
<meta property="og:description" content="天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="汉秋城">
<meta name="twitter:description" content="天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>汉秋城</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">汉秋城</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/18/OC二叉树相关操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="汉秋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汉秋城">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/OC二叉树相关操作/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T14:27:25+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#二叉树-你必须要懂！（二叉树相关算法实现-iOS）</p>
<p>####<a href="http://www.cnblogs.com/manji/p/4903990.html" target="_blank" rel="external">http://www.cnblogs.com/manji/p/4903990.html原文链接</a><br>这几天详细了解了下二叉树的相关算法，原因是看了唐boy的一篇博客（<a href="http://blog.devtang.com/blog/2015/06/16/talk-about-tech-interview/" target="_blank" rel="external">你会翻转二叉树吗？</a>），还有一篇关于<a href="http://www.cocoachina.com/programmer/20151015/13687.html" target="_blank" rel="external">百度的校园招聘面试经历</a>，深刻体会到二叉树的重要性。于是乎，从网上收集并整理了一些关于二叉树的资料，及相关算法的实现（主要是Objective-C的，但是算法思想是相通的），以便以后复习时查阅。</p>
<p>##什么是二叉树？<br>在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”和“右子树”，左子树和右子树同时也是二叉树。二叉树的子树有左右之分，并且次序不能任意颠倒。二叉树是递归定义的，所以一般二叉树的相关题目也都可以使用递归的思想来解决，当然也有一些可以使用非递归的思想解决，我下面列出的一些算法有些采用了递归，有些是非递归的。</p>
<p>#什么是二叉排序树？<br>二叉排序树又叫二叉查找树或者二叉搜索树，它首先是一个二叉树，而且必须满足下面的条件：<br>1）若左子树不空，则左子树上所有结点的值均小于它的根节点的值；<br>2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值<br>3）左、右子树也分别为二叉排序树<br>4）没有键值相等的节点（？可能是因为不好处理键值相等的节点到底是左节点还是右节点吧）<br>概念就介绍这么多，都是来自网上，下面主要看算法和具体实现代码。</p>
<p>#二叉树节点定义<br>采用单项链表的形式，只从根节点指向孩子节点，不保存父节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树节点</div><div class="line"> */</div><div class="line">@interface BinaryTreeNode : NSObject</div><div class="line"></div><div class="line">/**</div><div class="line"> *  值</div><div class="line"> */</div><div class="line">@property (nonatomic, assign) NSInteger value;</div><div class="line">/**</div><div class="line"> *  左节点</div><div class="line"> */</div><div class="line">@property (nonatomic, strong) BinaryTreeNode *leftNode;</div><div class="line">/**</div><div class="line"> *  右节点</div><div class="line"> */</div><div class="line">@property (nonatomic, strong) BinaryTreeNode *rightNode;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>#创建二叉排序树<br>二叉树中左右节点值本身没有大小之分，所以如果要创建二叉树，就需要考虑如何处理某个节点是左节点还是右节点，如何终止某个子树而切换到另一个子树。 因此我选择了二叉排序树，二叉排序树中对于左右节点有明确的要求，程序可以自动根据键值大小自动选择是左节点还是右节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  创建二叉排序树</div><div class="line"> *  二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值</div><div class="line"> *</div><div class="line"> *  @param values 数组</div><div class="line"> *</div><div class="line"> *  @return 二叉树根节点</div><div class="line"> */</div><div class="line">+ (BinaryTreeNode *)createTreeWithValues:(NSArray *)values &#123;</div><div class="line">    </div><div class="line">    BinaryTreeNode *root = nil;</div><div class="line">    for (NSInteger i=0; i&lt;values.count; i++) &#123;</div><div class="line">        NSInteger value = [(NSNumber *)[values objectAtIndex:i] integerValue];</div><div class="line">        root = [BinaryTree addTreeNode:root value:value];</div><div class="line">    &#125;</div><div class="line">    return root;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  向二叉排序树节点添加一个节点</div><div class="line"> *</div><div class="line"> *  @param treeNode 根节点</div><div class="line"> *  @param value    值</div><div class="line"> *</div><div class="line"> *  @return 根节点</div><div class="line"> */</div><div class="line">+ (BinaryTreeNode *)addTreeNode:(BinaryTreeNode *)treeNode value:(NSInteger)value &#123;</div><div class="line">    //根节点不存在，创建节点</div><div class="line">    if (!treeNode) &#123;</div><div class="line">        treeNode = [BinaryTreeNode new];</div><div class="line">        treeNode.value = value;</div><div class="line">        NSLog(@&quot;node:%@&quot;, @(value));</div><div class="line">    &#125;</div><div class="line">    else if (value &lt;= treeNode.value) &#123;</div><div class="line">        NSLog(@&quot;to left&quot;);</div><div class="line">        //值小于根节点，则插入到左子树</div><div class="line">        treeNode.leftNode = [BinaryTree addTreeNode:treeNode.leftNode value:value];</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        NSLog(@&quot;to right&quot;);</div><div class="line">        //值大于根节点，则插入到右子树</div><div class="line">        treeNode.rightNode = [BinaryTree addTreeNode:treeNode.rightNode value:value];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return treeNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树中某个位置的节点<br>类似索引操作，按层次遍历，位置从0开始算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树中某个位置的节点（按层次遍历）</div><div class="line"> *</div><div class="line"> *  @param index    按层次遍历树时的位置(从0开始算)</div><div class="line"> *  @param rootNode 树根节点</div><div class="line"> *</div><div class="line"> *  @return 节点</div><div class="line"> */</div><div class="line">+ (BinaryTreeNode *)treeNodeAtIndex:(NSInteger)index inTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    //按层次遍历</div><div class="line">    if (!rootNode || index &lt; 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列</div><div class="line">    [queueArray addObject:rootNode]; //压入根节点</div><div class="line">    while (queueArray.count &gt; 0) &#123;</div><div class="line">        </div><div class="line">        BinaryTreeNode *node = [queueArray firstObject];</div><div class="line">        if (index == 0) &#123;</div><div class="line">            return node;</div><div class="line">        &#125;</div><div class="line">        [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则</div><div class="line">        index--; //移除节点，index减少</div><div class="line">        </div><div class="line">        if (node.leftNode) &#123;</div><div class="line">            [queueArray addObject:node.leftNode]; //压入左节点</div><div class="line">        &#125;</div><div class="line">        if (node.rightNode) &#123;</div><div class="line">            [queueArray addObject:node.rightNode]; //压入右节点</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //层次遍历完，仍然没有找到位置，返回nil</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#先序遍历<br>先访问根，再遍历左子树，再遍历右子树。典型的递归思想。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  先序遍历</div><div class="line"> *  先访问根，再遍历左子树，再遍历右子树</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *  @param handler  访问节点处理函数</div><div class="line"> */</div><div class="line">+ (void)preOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123;</div><div class="line">    if (rootNode) &#123;</div><div class="line">        </div><div class="line">        if (handler) &#123;</div><div class="line">            handler(rootNode);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        [self preOrderTraverseTree:rootNode.leftNode handler:handler];</div><div class="line">        [self preOrderTraverseTree:rootNode.rightNode handler:handler];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用方法如下：（用到了block）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *orderArray = [NSMutableArray array];</div><div class="line">[BinaryTree preOrderTraverseTree:root handler:^(BinaryTreeNode *treeNode) &#123;</div><div class="line">     [orderArray addObject:@(treeNode.value)];</div><div class="line">&#125;];</div><div class="line">NSLog(@&quot;先序遍历结果：%@&quot;, [orderArray componentsJoinedByString:@&quot;,&quot;]);</div></pre></td></tr></table></figure></p>
<p>#中序遍历<br>先遍历左子树，再访问根，再遍历右子树。<br>对于二叉排序树来说，中序遍历得到的序列是一个从小到大排序好的序列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  中序遍历</div><div class="line"> *  先遍历左子树，再访问根，再遍历右子树</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *  @param handler  访问节点处理函数</div><div class="line"> */</div><div class="line">+ (void)inOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123;</div><div class="line">    if (rootNode) &#123;</div><div class="line">        [self inOrderTraverseTree:rootNode.leftNode handler:handler];</div><div class="line">        </div><div class="line">        if (handler) &#123;</div><div class="line">            handler(rootNode);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        [self inOrderTraverseTree:rootNode.rightNode handler:handler];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#后序遍历<br>先遍历左子树，再遍历右子树，再访问根<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  后序遍历</div><div class="line"> *  先遍历左子树，再遍历右子树，再访问根</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *  @param handler  访问节点处理函数</div><div class="line"> */</div><div class="line">+ (void)postOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123;</div><div class="line">    if (rootNode) &#123;</div><div class="line">        [self postOrderTraverseTree:rootNode.leftNode handler:handler];</div><div class="line">        [self postOrderTraverseTree:rootNode.rightNode handler:handler];</div><div class="line">        </div><div class="line">        if (handler) &#123;</div><div class="line">            handler(rootNode);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#层次遍历<br>按照从上到下、从左到右的次序进行遍历。先遍历完一层，再遍历下一层，因此又叫广度优先遍历。需要用到队列，在OC里可以用可变数组来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  层次遍历（广度优先）</div><div class="line"> *</div><div class="line"> *  @param rootNode 二叉树根节点</div><div class="line"> *  @param handler  访问节点处理函数</div><div class="line"> */</div><div class="line">+ (void)levelTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列</div><div class="line">    [queueArray addObject:rootNode]; //压入根节点</div><div class="line">    while (queueArray.count &gt; 0) &#123;</div><div class="line">        </div><div class="line">        BinaryTreeNode *node = [queueArray firstObject];</div><div class="line">        </div><div class="line">        if (handler) &#123;</div><div class="line">            handler(node);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则</div><div class="line">        if (node.leftNode) &#123;</div><div class="line">            [queueArray addObject:node.leftNode]; //压入左节点</div><div class="line">        &#125;</div><div class="line">        if (node.rightNode) &#123;</div><div class="line">            [queueArray addObject:node.rightNode]; //压入右节点</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树的深度<br>二叉树的深度定义为：从根节点到叶子结点依次经过的结点形成树的一条路径,最长路径的长度为树的深度。</p>
<p>1）如果根节点为空，则深度为0；</p>
<p>2）如果左右节点都是空，则深度为1；</p>
<p>3）递归思想：二叉树的深度=max（左子树的深度，右子树的深度）+ 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树的深度</div><div class="line"> *</div><div class="line"> *  @param rootNode 二叉树根节点</div><div class="line"> *</div><div class="line"> *  @return 二叉树的深度</div><div class="line"> */</div><div class="line">+ (NSInteger)depthOfTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //左子树深度</div><div class="line">    NSInteger leftDepth = [self depthOfTree:rootNode.leftNode];</div><div class="line">    //右子树深度</div><div class="line">    NSInteger rightDepth = [self depthOfTree:rootNode.rightNode];</div><div class="line">    </div><div class="line">    return MAX(leftDepth, rightDepth) + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树的宽度<br>二叉树的宽度定义为各层节点数的最大值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树的宽度</div><div class="line"> *</div><div class="line"> *  @param rootNode 二叉树根节点</div><div class="line"> *</div><div class="line"> *  @return 二叉树宽度</div><div class="line"> */</div><div class="line">+ (NSInteger)widthOfTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列</div><div class="line">    [queueArray addObject:rootNode]; //压入根节点</div><div class="line">    NSInteger maxWidth = 1; //最大的宽度，初始化为1（因为已经有根节点）</div><div class="line">    NSInteger curWidth = 0; //当前层的宽度</div><div class="line">    </div><div class="line">    while (queueArray.count &gt; 0) &#123;</div><div class="line">        </div><div class="line">        curWidth = queueArray.count;</div><div class="line">        //依次弹出当前层的节点</div><div class="line">        for (NSInteger i=0; i&lt;curWidth; i++) &#123;</div><div class="line">            BinaryTreeNode *node = [queueArray firstObject];</div><div class="line">            [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则</div><div class="line">            //压入子节点</div><div class="line">            if (node.leftNode) &#123;</div><div class="line">                [queueArray addObject:node.leftNode];</div><div class="line">            &#125;</div><div class="line">            if (node.rightNode) &#123;</div><div class="line">                [queueArray addObject:node.rightNode];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //宽度 = 当前层节点数</div><div class="line">        maxWidth = MAX(maxWidth, queueArray.count);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return maxWidth;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树的所有节点数<br>递归思想：二叉树所有节点数=左子树节点数+右子树节点数+1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树的所有节点数</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return 所有节点数</div><div class="line"> */</div><div class="line">+ (NSInteger)numberOfNodesInTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    //节点数=左子树节点数+右子树节点数+1（根节点）</div><div class="line">    return [self numberOfNodesInTree:rootNode.leftNode] + [self numberOfNodesInTree:rootNode.rightNode] + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树某层中的节点数<br>1）根节点为空，则节点数为0；</p>
<p>2）层为1，则节点数为1（即根节点）</p>
<p>3）递归思想：二叉树第k层节点数=左子树第k-1层节点数+右子树第k-1层节点数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树某层中的节点数</div><div class="line"> *</div><div class="line"> *  @param level    层</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return 层中的节点数</div><div class="line"> */</div><div class="line">+ (NSInteger)numberOfNodesOnLevel:(NSInteger)level inTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode || level &lt; 1) &#123; //根节点不存在或者level&lt;0</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if (level == 1) &#123; //level=1，返回1（根节点）</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    //递归：level层节点数 = 左子树level-1层节点数+右子树level-1层节点数</div><div class="line">    return [self numberOfNodesOnLevel:level-1 inTree:rootNode.leftNode] + [self numberOfNodesOnLevel:level-1 inTree:rootNode.rightNode];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树叶子节点数<br>叶子节点，又叫终端节点，是左右子树都是空的节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树叶子节点数</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return 叶子节点数</div><div class="line"> */</div><div class="line">+ (NSInteger)numberOfLeafsInTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    //左子树和右子树都是空，说明是叶子节点</div><div class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    //递归：叶子数 = 左子树叶子数 + 右子树叶子数</div><div class="line">    return [self numberOfLeafsInTree:rootNode.leftNode] + [self numberOfLeafsInTree:rootNode.rightNode];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树最大距离（二叉树的直径）<br>二叉树中任意两个节点都有且仅有一条路径，这个路径的长度叫这两个节点的距离。二叉树中所有节点之间的距离的最大值就是二叉树的直径。</p>
<p>有一种解法，把这个最大距离划分了3种情况：</p>
<p>1）这2个节点分别在根节点的左子树和右子树上，他们之间的路径肯定经过根节点，而且他们肯定是根节点左右子树上最远的叶子节点（他们到根节点的距离=左右子树的深度）。</p>
<p>2）这2个节点都在左子树上</p>
<p>3）这2个节点都在右子树上</p>
<p>综上，只要取这3种情况中的最大值，就是二叉树的直径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树最大距离（直径）</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return 最大距离</div><div class="line"> */</div><div class="line">+ (NSInteger)maxDistanceOfTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">//    方案一：（递归次数较多，效率较低）</div><div class="line">    //分3种情况：</div><div class="line">    //1、最远距离经过根节点：距离 = 左子树深度 + 右子树深度</div><div class="line">    NSInteger distance = [self depthOfTree:rootNode.leftNode] + [self depthOfTree:rootNode.rightNode];</div><div class="line">    //2、最远距离在根节点左子树上，即计算左子树最远距离</div><div class="line">    NSInteger disLeft = [self maxDistanceOfTree:rootNode.leftNode];</div><div class="line">    //3、最远距离在根节点右子树上，即计算右子树最远距离</div><div class="line">    NSInteger disRight = [self maxDistanceOfTree:rootNode.rightNode];</div><div class="line">    </div><div class="line">    return MAX(MAX(disLeft, disRight), distance);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方案效率较低，因为计算子树的深度和最远距离是分开递归的，存在重复递归遍历的情况。其实一次递归，就可以分别计算出深度和最远距离，于是有了第二种方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树最大距离（直径）</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return 最大距离</div><div class="line"> */</div><div class="line">+ (NSInteger)maxDistanceOfTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">//    方案2：将计算节点深度和最大距离放到一次递归中计算，方案一是分别单独递归计算深度和最远距离</div><div class="line">    TreeNodeProperty *p = [self propertyOfTreeNode:rootNode];</div><div class="line">    return p.distance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  计算树节点的最大深度和最大距离</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return TreeNodeProperty</div><div class="line"> */</div><div class="line">+ (TreeNodeProperty *)propertyOfTreeNode:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    </div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    TreeNodeProperty *left = [self propertyOfTreeNode:rootNode.leftNode];</div><div class="line">    TreeNodeProperty *right = [self propertyOfTreeNode:rootNode.rightNode];</div><div class="line">    TreeNodeProperty *p = [TreeNodeProperty new];</div><div class="line">    //节点的深度depth = 左子树深度、右子树深度中最大值+1（+1是因为根节点占了1个depth）</div><div class="line">    p.depth = MAX(left.depth, right.depth) + 1;</div><div class="line">    //最远距离 = 左子树最远距离、右子树最远距离和横跨左右子树最远距离中最大值</div><div class="line">    p.distance = MAX(MAX(left.distance, right.distance), left.depth+right.depth);</div><div class="line">    </div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树中某个节点到根节点的路径<br>既是寻路问题，又是查找节点问题。</p>
<p>定义一个存放路径的栈（不是队列了，但是还是用可变数组来实现的）</p>
<p>1）压入根节点，再从左子树中查找（递归进行的），如果未找到，再从右子树中查找，如果也未找到，则弹出根节点，再遍历栈中上一个节点。</p>
<p>2）如果找到，则栈中存放的节点就是路径所经过的节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树中某个节点到根节点的路径</div><div class="line"> *</div><div class="line"> *  @param treeNode 节点</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return 存放路径节点的数组</div><div class="line"> */</div><div class="line">+ (NSArray *)pathOfTreeNode:(BinaryTreeNode *)treeNode inTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    NSMutableArray *pathArray = [NSMutableArray array];</div><div class="line">    [self isFoundTreeNode:treeNode inTree:rootNode routePath:pathArray];</div><div class="line">    return pathArray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  查找某个节点是否在树中</div><div class="line"> *</div><div class="line"> *  @param treeNode 待查找的节点</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *  @param path  根节点到待查找节点的路径</div><div class="line"> *</div><div class="line"> *  @return YES：找到，NO：未找到</div><div class="line"> */</div><div class="line">+ (BOOL)isFoundTreeNode:(BinaryTreeNode *)treeNode inTree:(BinaryTreeNode *)rootNode routePath:(NSMutableArray *)path &#123;</div><div class="line">    </div><div class="line">    if (!rootNode || !treeNode) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //找到节点</div><div class="line">    if (rootNode == treeNode) &#123;</div><div class="line">        [path addObject:rootNode];</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    //压入根节点，进行递归</div><div class="line">    [path addObject:rootNode];</div><div class="line">    //先从左子树中查找</div><div class="line">    BOOL find = [self isFoundTreeNode:treeNode inTree:rootNode.leftNode routePath:path];</div><div class="line">    //未找到，再从右子树查找</div><div class="line">    if (!find) &#123;</div><div class="line">        find = [self isFoundTreeNode:treeNode inTree:rootNode.rightNode routePath:path];</div><div class="line">    &#125;</div><div class="line">    //如果2边都没查找到，则弹出此根节点</div><div class="line">    if (!find) &#123;</div><div class="line">        [path removeLastObject];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return find;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树中两个节点最近的公共父节点<br>首先需要明白，根节点肯定是二叉树中任意两个节点的公共父节点（不一定是最近的），因此二叉树中2个节点的最近公共父节点一定在从根节点到这个节点的路径上。因此我们可以先分别找到从根节点到这2个节点的路径，再从这两个路径中找到最近的公共父节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树中两个节点最近的公共父节点</div><div class="line"> *</div><div class="line"> *  @param nodeA    第一个节点</div><div class="line"> *  @param nodeB    第二个节点</div><div class="line"> *  @param rootNode 二叉树根节点</div><div class="line"> *</div><div class="line"> *  @return 最近的公共父节点</div><div class="line"> */</div><div class="line">+ (BinaryTreeNode *)parentOfNode:(BinaryTreeNode *)nodeA andNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode || !nodeA || !nodeB) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    if (nodeA == nodeB) &#123;</div><div class="line">        return nodeA;</div><div class="line">    &#125;</div><div class="line">    //从根节点到节点A的路径</div><div class="line">    NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode];</div><div class="line">    //从根节点到节点B的路径</div><div class="line">    NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode];</div><div class="line">    //其中一个节点不在树中，则没有公共父节点</div><div class="line">    if (pathA.count == 0 || pathB == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    //从后往前推，查找第一个出现的公共节点</div><div class="line">    for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123;</div><div class="line">        for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123;</div><div class="line">            if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123;</div><div class="line">                //找到</div><div class="line">                return [pathA objectAtIndex:i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树中两个节点之间的路径<br>从查找最近公共父节点衍生出来的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树中两个节点之间的路径</div><div class="line"> *</div><div class="line"> *  @param nodeA    第一个节点</div><div class="line"> *  @param nodeB    第二个节点</div><div class="line"> *  @param rootNode 二叉树根节点</div><div class="line"> *</div><div class="line"> *  @return 两个节点间的路径</div><div class="line"> */</div><div class="line">+ (NSArray *)pathFromNode:(BinaryTreeNode *)nodeA toNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode || !nodeA || !nodeB) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    NSMutableArray *path = [NSMutableArray array];</div><div class="line">    if (nodeA == nodeB) &#123;</div><div class="line">        [path addObject:nodeA];</div><div class="line">        [path addObject:nodeB];</div><div class="line">        return path;</div><div class="line">    &#125;</div><div class="line">    //从根节点到节点A的路径</div><div class="line">    NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode];</div><div class="line">    //从根节点到节点B的路径</div><div class="line">    NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode];</div><div class="line">    //其中一个节点不在树中，则没有路径</div><div class="line">    if (pathA.count == 0 || pathB == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    //从后往前推，查找第一个出现的公共节点</div><div class="line">    for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123;</div><div class="line">        [path addObject:[pathA objectAtIndex:i]];</div><div class="line">        for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123;</div><div class="line">            //找到公共父节点，则将pathB中后面的节点压入path</div><div class="line">            if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123;</div><div class="line">                j++; //j++是为了避开公共父节点</div><div class="line">                while (j&lt;pathB.count) &#123;</div><div class="line">                    [path addObject:[pathB objectAtIndex:j]];</div><div class="line">                    j++;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                return path;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#二叉树两个节点之间的距离<br>可以从两个节点之间的路径衍生出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  二叉树两个节点之间的距离</div><div class="line"> *</div><div class="line"> *  @param nodeA    第一个节点</div><div class="line"> *  @param nodeB    第二个节点</div><div class="line"> *  @param rootNode 二叉树根节点</div><div class="line"> *</div><div class="line"> *  @return 两个节点间的距离（-1：表示没有找到路径）</div><div class="line"> */</div><div class="line">+ (NSInteger)distanceFromNode:(BinaryTreeNode *)nodeA toNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode || !nodeA || !nodeB) &#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    if (nodeA == nodeB) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    //从根节点到节点A的路径</div><div class="line">    NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode];</div><div class="line">    //从根节点到节点B的路径</div><div class="line">    NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode];</div><div class="line">    //其中一个节点不在树中，则没有路径</div><div class="line">    if (pathA.count == 0 || pathB == 0) &#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    //从后往前推，查找第一个出现的公共节点</div><div class="line">    for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123;</div><div class="line">        for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123;</div><div class="line">            //找到公共父节点</div><div class="line">            if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123;</div><div class="line">                //距离=路径节点数-1 （这里要-2，因为公共父节点重复了一次）</div><div class="line">                return (pathA.count - i) + (pathB.count - j) - 2;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#翻转二叉树<br>你会翻转二叉树吗？如果不会，那对不起，我们不会录用你！</p>
<p>翻转二叉树，又叫求二叉树的镜像，就是把二叉树的左右子树对调（当然是递归的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  翻转二叉树（又叫：二叉树的镜像）</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return 翻转后的树根节点（其实就是原二叉树的根节点）</div><div class="line"> */</div><div class="line">+ (BinaryTreeNode *)invertBinaryTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</div><div class="line">        return rootNode;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [self invertBinaryTree:rootNode.leftNode];</div><div class="line">    [self invertBinaryTree:rootNode.rightNode];</div><div class="line">    </div><div class="line">    BinaryTreeNode *tempNode = rootNode.leftNode;</div><div class="line">    rootNode.leftNode = rootNode.rightNode;</div><div class="line">    rootNode.rightNode = tempNode;</div><div class="line">    </div><div class="line">    return rootNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#判断二叉树是否完全二叉树<br>完全二叉树定义为：若设二叉树的高度为h，除第h层外，其它各层的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布。</p>
<p>完全二叉树必须满足2个条件：</p>
<p>1）如果某个节点的右子树不为空，则它的左子树必须不为空</p>
<p>2）如果某个节点的右子树为空，则排在它后面的节点必须没有孩子节点</p>
<p>这里还需要理解“排在它后面的节点”，回头看看层次遍历算法，我们就能知道在层次遍历时，是从上到下从左到右遍历的，先将根节点弹出队列，再压入孩子节点，因此“排在它后面的节点”有2种情况：</p>
<p>1）同层次的后面的节点</p>
<p>2）同层次的前面的节点的孩子节点（因为遍历前面的节点时，会弹出节点，同时将孩子节点压入队列）</p>
<p>通过上面的分析，我们可以设置一个标志位flag，当子树满足完全二叉树时，设置flag=YES。当flag=YES而节点又破坏了完全二叉树的条件，那么它就不是完全二叉树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  是否完全二叉树</div><div class="line"> *  完全二叉树：若设二叉树的高度为h，除第h层外，其它各层的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return YES：是完全二叉树，NO：不是完全二叉树</div><div class="line"> */</div><div class="line">+ (BOOL)isCompleteBinaryTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    //左子树和右子树都是空，则是完全二叉树</div><div class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    //左子树是空，右子树不是空，则不是完全二叉树</div><div class="line">    if (!rootNode.leftNode &amp;&amp; rootNode.rightNode) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //按层次遍历节点，找到满足完全二叉树的条件：</div><div class="line">    //条件1：如果某个节点的右子树不为空，则它的左子树必须不为空</div><div class="line">    //条件2：如果某个节点的右子树为空，则排在它后面的节点必须没有孩子节点</div><div class="line">    //排在该节点后面的节点有2种：1）同层次的后面的节点 2）同层次的前面的节点的孩子节点（因为遍历前面的节点的时候，会将节点从队列里pop，同时把它的孩子节点push到队列里）</div><div class="line">    NSMutableArray *queue = [NSMutableArray array];</div><div class="line">    [queue addObject:rootNode];</div><div class="line">    BOOL isComplete = NO; //是否已经满足完全二叉树</div><div class="line">    while (queue.count &gt; 0) &#123;</div><div class="line">        BinaryTreeNode *node = [queue firstObject];</div><div class="line">        [queue removeObjectAtIndex:0];</div><div class="line">        </div><div class="line">        //左子树为空且右子树不为空，则不是完全二叉树</div><div class="line">        if (!node.leftNode &amp;&amp; node.rightNode) &#123;</div><div class="line">            return NO;</div><div class="line">        &#125;</div><div class="line">        if (isComplete &amp;&amp; (node.leftNode || node.rightNode)) &#123;</div><div class="line">            //前面的节点已满足完全二叉树,如果还有孩子节点，则不是完全二叉树</div><div class="line">            return NO;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //右子树为空，则已经满足完全二叉树</div><div class="line">        if (!node.rightNode) &#123;</div><div class="line">            isComplete = YES;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //压入</div><div class="line">        if (node.leftNode) &#123;</div><div class="line">            [queue addObject:node.leftNode];</div><div class="line">        &#125;</div><div class="line">        if (node.rightNode) &#123;</div><div class="line">            [queue addObject:node.rightNode];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return isComplete;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#判断二叉树是否满二叉树<br> 满二叉树定义为：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树</p>
<p> 满二叉树的一个特性是：叶子数=2^(深度-1)，因此我们可以根据这个特性来判断二叉树是否是满二叉树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  是否满二叉树</div><div class="line"> *  满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return YES：满二叉树，NO：非满二叉树</div><div class="line"> */</div><div class="line">+ (BOOL)isFullBinaryTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //二叉树深度</div><div class="line">    NSInteger depth = [self depthOfTree:rootNode];</div><div class="line">    //二叉树叶子节点数</div><div class="line">    NSInteger leafNum = [self numberOfLeafsInTree:rootNode];</div><div class="line">    </div><div class="line">    //满二叉树特性：叶子数=2^(深度-1)</div><div class="line">    if (leafNum == pow(2, (depth - 1))) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#判断二叉树是否平衡二叉树<br>平衡二叉树定义为：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树又叫AVL树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  是否平衡二叉树</div><div class="line"> *  平衡二叉树：即AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</div><div class="line"> *</div><div class="line"> *  @param rootNode 根节点</div><div class="line"> *</div><div class="line"> *  @return YES：平衡二叉树，NO：非平衡二叉树</div><div class="line"> */</div><div class="line">+ (BOOL)isAVLBinaryTree:(BinaryTreeNode *)rootNode &#123;</div><div class="line">    static NSInteger height;</div><div class="line">    if (!rootNode) &#123;</div><div class="line">        height = 0;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</div><div class="line">        height = 1;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    BOOL isAVLLeft = [self isAVLBinaryTree:rootNode.leftNode];</div><div class="line">    NSInteger heightLeft = height;</div><div class="line">    BOOL isAVLRight = [self isAVLBinaryTree:rootNode.rightNode];</div><div class="line">    NSInteger heightRight = height;</div><div class="line">    </div><div class="line">    height = MAX(heightLeft, heightRight)+1;</div><div class="line">    </div><div class="line">    if (isAVLLeft &amp;&amp; isAVLRight &amp;&amp; ABS(heightLeft-heightRight) &lt;= 1) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="汉秋" />
            
              <p class="site-author-name" itemprop="name">汉秋</p>
              <p class="site-description motion-element" itemprop="description">天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/lujiuyin" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">汉秋</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
